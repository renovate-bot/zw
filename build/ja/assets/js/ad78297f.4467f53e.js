"use strict";(self.webpackChunkzw=self.webpackChunkzw||[]).push([[717],{9613:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(9496);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(t),m=i,c=h["".concat(o,".").concat(m)]||h[m]||u[m]||l;return t?a.createElement(c,r(r({ref:n},d),{},{components:t})):a.createElement(c,r({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=h;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<l;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},7227:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var a=t(2182),i=t(9028),l=(t(9496),t(9613)),r=["components"],s={id:"zsh_handbook",title:"Zsh Native Scripting Handbook"},o=void 0,p={unversionedId:"zsh_handbook",id:"zsh_handbook",title:"Zsh Native Scripting Handbook",description:"Information",source:"@site/community/03_zsh_native_scripting_handbook.md",sourceDirName:".",slug:"/zsh_handbook",permalink:"/ja/community/zsh_handbook",editUrl:"https://digitalclouds.crowdin.com/z-shell/ja",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"zsh_handbook",title:"Zsh Native Scripting Handbook"},sidebar:"autoSideBar_2",previous:{title:"Zsh Plugin Standard",permalink:"/ja/community/zsh_plugin_standard"}},d={},u=[{value:"Information",id:"information",level:2},{value:"@ is about keeping array form",id:"-is-about-keeping-array-form",level:3},{value:"extended_glob",id:"extended_glob",level:3},{value:"Constructs",id:"constructs",level:2},{value:"Reading a file",id:"reading-a-file",level:3},{value:"Reading from stdin",id:"reading-from-stdin",level:3},{value:"Skipping dirname basename",id:"skipping-dirname-basename",level:3},{value:"Resolve Symlinks",id:"resolve-symlinks",level:3},{value:"Skipping grep",id:"skipping-grep",level:3},{value:"Multi-line matching like with grep",id:"multi-line-matching-like-with-grep",level:4},{value:"Pattern matching in AND-fashion",id:"pattern-matching-in-and-fashion",level:3},{value:"Skipping tr",id:"skipping-tr",level:3},{value:"Ternary expressions with <code>+,-,:+,:-</code> substitutions",id:"ternary-expressions-with----substitutions",level:3},{value:"Ternary expressions with <code>:#</code> substitution",id:"ternary-expressions-with--substitution",level:3},{value:"Using built-in regular expressions engine",id:"using-built-in-regular-expressions-engine",level:3},{value:"Skipping uniq",id:"skipping-uniq",level:3},{value:"Skipping awk",id:"skipping-awk",level:3},{value:"Searching arrays",id:"searching-arrays",level:3},{value:"Code execution in <code>//</code> substitution",id:"code-execution-in--substitution",level:3},{value:"Serializing data",id:"serializing-data",level:3},{value:"Tip: serializing with Bash",id:"tip-serializing-with-bash",level:4},{value:"Real-world examples",id:"real-world-examples",level:2},{value:"Testing for Git subcommand",id:"testing-for-git-subcommand",level:3},{value:"Counting unquoted-only apostrophes",id:"counting-unquoted-only-apostrophes",level:3},{value:"Tips and Tricks",id:"tips-and-tricks",level:2},{value:"Parsing INI file",id:"parsing-ini-file",level:3}],h={toc:u};function m(e){var n=e.components,t=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"information"},"Information"),(0,l.kt)("h3",{id:"-is-about-keeping-array-form"},"@ is about keeping array form"),(0,l.kt)("p",null,"How to access all array elements in a shell? The standard answer: ",(0,l.kt)("inlineCode",{parentName:"p"},"use @ subscript"),", i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"${array[@]}"),". However, this\nis the Bash & Ksh way (and with the option ",(0,l.kt)("inlineCode",{parentName:"p"},"KSH_ARRAYS"),", Zsh also works this way, i.e. needs ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," to access the whole\narray). Z shell ",(0,l.kt)("strong",{parentName:"p"},"is different"),": it is ",(0,l.kt)("inlineCode",{parentName:"p"},"$array")," that refers to all elements anyway. There is no need for the ",(0,l.kt)("inlineCode",{parentName:"p"},"@"),"\nsubscript."),(0,l.kt)("p",null,"So what use has ",(0,l.kt)("inlineCode",{parentName:"p"},"@"),' in the Zsh-world? It is: "',(0,l.kt)("inlineCode",{parentName:"p"},"keep array form"),'" or "',(0,l.kt)("inlineCode",{parentName:"p"},"do not join"),'". When is it activated? When the user\nquotes the array, i.e. invokes ',(0,l.kt)("inlineCode",{parentName:"p"},'"$array"'),", he induces ",(0,l.kt)("em",{parentName:"p"},"joining")," of all array elements (into a single string). ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," is to\nhave elements still quoted (so empty elements are preserved), but not joined."),(0,l.kt)("p",null,"Two forms are available, ",(0,l.kt)("inlineCode",{parentName:"p"},'"$array[@]"')," and ",(0,l.kt)("inlineCode",{parentName:"p"},'"${(@)array}"'),". The first form has an additional effect \u2013 when an option\n",(0,l.kt)("inlineCode",{parentName:"p"},"KSH_ARRAYS")," is set, it indeed induces referencing to the whole array instead of a first element only. It should then\nuse braces, i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"${array[@]}"),", ",(0,l.kt)("inlineCode",{parentName:"p"},'"${array[@]}"')," (",(0,l.kt)("inlineCode",{parentName:"p"},"KSH_ARRAYS")," requirement)."),(0,l.kt)("p",null,"In practice, if you'll use ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," as a subscript \u2013 ",(0,l.kt)("inlineCode",{parentName:"p"},"[@]"),", not as a flag \u2013 ",(0,l.kt)("inlineCode",{parentName:"p"},"${(@)...}"),", then you'll make the code\n",(0,l.kt)("inlineCode",{parentName:"p"},"KSH_ARRAYS"),"-compatible."),(0,l.kt)("h3",{id:"extended_glob"},"extended_glob"),(0,l.kt)("p",null,"Glob-flags ",(0,l.kt)("inlineCode",{parentName:"p"},"#b")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"#m")," require ",(0,l.kt)("inlineCode",{parentName:"p"},"setopt extended_glob"),". Patterns utilizing ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"^")," also require it. Extended-glob\nis one of the main features of Zsh."),(0,l.kt)("h2",{id:"constructs"},"Constructs"),(0,l.kt)("h3",{id:"reading-a-file"},"Reading a file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a lines; lines=( "${(@f)"$(<path/file)"}" )\n')),(0,l.kt)("p",null,"This preserves empty lines because of double-quoting (the outside one). ",(0,l.kt)("inlineCode",{parentName:"p"},"@"),"-flag is used to obtain an array instead of a\nscalar. If you don't want empty lines preserved, you can also skip ",(0,l.kt)("inlineCode",{parentName:"p"},"@"),"-splitting, as is explained in the\n",(0,l.kt)("a",{parentName:"p",href:"#information"},"Information")," section:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a lines; lines=( ${(f)"$(<path/file)"} )\n')),(0,l.kt)("p",null,"Note: ",(0,l.kt)("inlineCode",{parentName:"p"},"$(<...)")," construct strips trailing empty lines."),(0,l.kt)("h3",{id:"reading-from-stdin"},"Reading from stdin"),(0,l.kt)("p",null,"This topic is governed by the same principles a the previous paragraph (",(0,l.kt)("inlineCode",{parentName:"p"},"Reading a file"),"), with the single difference\nthat instead of the substitution ",(0,l.kt)("inlineCode",{parentName:"p"},'"$(<file-path)"')," the substitution that should be used is ",(0,l.kt)("inlineCode",{parentName:"p"},'"$(command arg1 ...)"'),",\ni.e.:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a lines; lines=( ${(f)"$(command arg1 ...)"} )\n')),(0,l.kt)("p",null,"This will read the ",(0,l.kt)("inlineCode",{parentName:"p"},"command's")," output into the array ",(0,l.kt)("inlineCode",{parentName:"p"},"lines"),". The version that does ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," splitting and retains any empty\nlines are:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a lines; lines=( "${(f@)$(command arg1 ...)}" )\n')),(0,l.kt)("p",null,"Note that instead of four double-quotes ",(0,l.kt)("inlineCode",{parentName:"p"},'"'),", an idiom that is justified (simply suggested) by the Zsh documentation (and\nwas used in the previous paragraph, in the snippet ",(0,l.kt)("inlineCode",{parentName:"p"},'... "${(@f)"$(<path/file)"}" ...'),"), only ",(0,l.kt)("strong",{parentName:"p"},"two")," double-quotes are\nbeing used. I've investigated this form with the main Zsh developers on the ",(0,l.kt)("inlineCode",{parentName:"p"},"zsh-workers@zsh.org")," mailing list and it\nwas clearly stated that single, outside quoting of ",(0,l.kt)("inlineCode",{parentName:"p"},"${(f@)...}")," substitution works as if it was also separately applied\nto ",(0,l.kt)("inlineCode",{parentName:"p"},"$(command ...)")," (or to ",(0,l.kt)("inlineCode",{parentName:"p"},"$(<file-path)"),") inner substitution, so the second double-quoting isn't needed."),(0,l.kt)("h3",{id:"skipping-dirname-basename"},"Skipping dirname basename"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"dirname")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"basename")," can be skipped by:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local dirname="${PWD:h}"\nlocal basename="${PWD:t}"\n')),(0,l.kt)("p",null,"Read more: ",(0,l.kt)("a",{parentName:"p",href:"http://zsh.sourceforge.net/Doc/Release/Expansion.html#Modifiers"},"zsh: 14 Expansion"),"."),(0,l.kt)("h3",{id:"resolve-symlinks"},"Resolve Symlinks"),(0,l.kt)("p",null,"Symbolic links can be turned into an absolute path with:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local absolute_path="${PWD:A}"\n')),(0,l.kt)("h3",{id:"skipping-grep"},"Skipping grep"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a lines; lines=( "${(@f)"$(<path/file)"}" )\ndeclare -a grepped; grepped=( ${(M)lines:#*query*} )\n')),(0,l.kt)("p",null,"To have the ",(0,l.kt)("inlineCode",{parentName:"p"},"grep -v")," effect, skip the ",(0,l.kt)("inlineCode",{parentName:"p"},"M"),"-flag. To grep case-insensitively, use ",(0,l.kt)("inlineCode",{parentName:"p"},"\\#i")," glob flag (",(0,l.kt)("inlineCode",{parentName:"p"},"...:#(#i)\\*query*}"),")."),(0,l.kt)("p",null,"As it can be seen, ",(0,l.kt)("inlineCode",{parentName:"p"},"${...:#...}")," substitution is filtering of the array, which by default filters-out elements (",(0,l.kt)("inlineCode",{parentName:"p"},"(M)"),"\nflag induces the opposite behavior). When used with string, not an array, it behaves similarly: returns an empty string\nwhen ",(0,l.kt)("inlineCode",{parentName:"p"},"{input_string_var:#pattern}")," matches the whole input string."),(0,l.kt)("p",null,"Side-note: ",(0,l.kt)("inlineCode",{parentName:"p"},"(M)")," flag can be used also with ",(0,l.kt)("inlineCode",{parentName:"p"},"${(M)var#pattern}")," and other substitutions, to retain what's matched by the\npattern instead of removing that."),(0,l.kt)("h4",{id:"multi-line-matching-like-with-grep"},"Multi-line matching like with grep"),(0,l.kt)("p",null,"Suppose you have a Subversion repository and want to check if it contains files being not under version control. You\ncould do this in Bash style like follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local svn_status="$(svn status)"\nif [[ -n "$(echo "$svn_status" | \\grep \\^\\?)" ]]; then\n    echo found\nfi\n')),(0,l.kt)("p",null,"Those are 3 forks: for ",(0,l.kt)("inlineCode",{parentName:"p"},"svn status"),", for ",(0,l.kt)("inlineCode",{parentName:"p"},"echo"),", and for ",(0,l.kt)("inlineCode",{parentName:"p"},"grep"),". This can be solved by the ",(0,l.kt)("inlineCode",{parentName:"p"},":#")," substitution and ",(0,l.kt)("inlineCode",{parentName:"p"},"(M)"),"\nflag described above in this section (just check if the number of matched lines is greater than 0). However, there's a\nmore direct approach:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local svn_status="$(svn status)" nl=$\'\\n\'\nif [[ "$svn_status" = *((#s)|$nl)\\?* ]]; then\n  echo found\nfi\n')),(0,l.kt)("p",null,"This requires ",(0,l.kt)("inlineCode",{parentName:"p"},"extendedglob"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"(#s)"),' means: "start of the string". So ',(0,l.kt)("inlineCode",{parentName:"p"},"((#s)|$nl)"),' means "start of the string OR\npreceded by a new-line".'),(0,l.kt)("p",null,"If the ",(0,l.kt)("inlineCode",{parentName:"p"},"extendedglob")," option cannot be used for some reason, this can be achieved also without it, but essentially it\nmeans that alternative (i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),") of two versions of the pattern will have to be matched:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'setopt localoptions noextendedglob\nlocal svn_status="$(svn status)" nl=$\'\\n\'\nif [[ "$svn_status" = (\\?*|*$nl\\?*) ]]; then\n  echo found\nfi\n')),(0,l.kt)("p",null,"In general, multi-line matching falls into the following idiom (",(0,l.kt)("inlineCode",{parentName:"p"},"extended glob")," version):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local needle="?" required_preceding=\'[[:space:]]#\'\n[[ "$(svn status)" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found\n')),(0,l.kt)("p",null,"It does a single fork (calls ",(0,l.kt)("inlineCode",{parentName:"p"},"svn")," status). The ",(0,l.kt)("inlineCode",{parentName:"p"},"${~variable}")," means (the",(0,l.kt)("inlineCode",{parentName:"p"},"~"),' init): "the variable is holding a pattern,\ninterpret it". All in all, instead of regular expressions we were using patterns (globs) (see\n',(0,l.kt)("a",{parentName:"p",href:"#built-in-regular-expressions-engine"},"this section"),")."),(0,l.kt)("h3",{id:"pattern-matching-in-and-fashion"},"Pattern matching in AND-fashion"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'[[ "abc xyz efg" = *abc*~^*efg* ]] && print Match found\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," is a negation -- ",(0,l.kt)("inlineCode",{parentName:"p"},"match \\*abc* but not ..."),". Then, ",(0,l.kt)("inlineCode",{parentName:"p"},"^")," is also a negation. The effect is:\n",(0,l.kt)("inlineCode",{parentName:"p"},"\\*ABC* but not those that don't have \\*efg*")," which equals to: ",(0,l.kt)("inlineCode",{parentName:"p"},"\\*ABC* but those that have also \\*efg*"),". This is a\nregular pattern and it can be used with ",(0,l.kt)("inlineCode",{parentName:"p"},":#")," above to search arrays, or with the ",(0,l.kt)("inlineCode",{parentName:"p"},"R"),"-subscript flag to search hashes\n(",(0,l.kt)("inlineCode",{parentName:"p"},"${hsh[\\(R)\\*pattern*]}"),"), etc. The inventor of those patterns is Mikael Magnusson."),(0,l.kt)("h3",{id:"skipping-tr"},"Skipping tr"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -A map; map=( a 1 b 2 );\ntext=( "ab" "ba" )\ntext=( ${text[@]//(#m)?/${map[$MATCH]}} )\nprint $text \u25b6 12 21\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"#m")," flag enables the ",(0,l.kt)("inlineCode",{parentName:"p"},"$MATCH")," parameter. At each ",(0,l.kt)("inlineCode",{parentName:"p"},"//")," substitution, ",(0,l.kt)("inlineCode",{parentName:"p"},"$map")," is queried for character-replacement. You\ncan substitute a text variable too, just skip ",(0,l.kt)("inlineCode",{parentName:"p"},"[@]")," and parentheses in the assignment."),(0,l.kt)("h3",{id:"ternary-expressions-with----substitutions"},"Ternary expressions with ",(0,l.kt)("inlineCode",{parentName:"h3"},"+,-,:+,:-")," substitutions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'HELP="yes"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled\nHELP=""; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled\n')),(0,l.kt)("p",null,"Ternary expression is known from ",(0,l.kt)("inlineCode",{parentName:"p"},"C")," language but exists also in Zsh, but directly only in a math context, i.e.\n",(0,l.kt)("inlineCode",{parentName:"p"},"\\(( a = a > 0 ? b : c ))"),". The flexibility of Zsh allows such expressions also in a normal context. Above is an\nexample. ",(0,l.kt)("inlineCode",{parentName:"p"},":+"),' is "if not empty, substitute \u2026" ',(0,l.kt)("inlineCode",{parentName:"p"},":-"),' is "if empty, substitute \u2026". You can save a great number of lines of\ncode with those substitutions, it\'s normally at least 4-lines ',(0,l.kt)("inlineCode",{parentName:"p"},"if")," condition or lengthy ",(0,l.kt)("inlineCode",{parentName:"p"},"&&"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"||")," use."),(0,l.kt)("h3",{id:"ternary-expressions-with--substitution"},"Ternary expressions with ",(0,l.kt)("inlineCode",{parentName:"h3"},":#")," substitution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc\nvar=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc\n")),(0,l.kt)("p",null,'A one-line "if var = x, then \u2026, else \u2026". Again, can spare a great amount of boring code that makes a 10-line function a\n20-line one.'),(0,l.kt)("p",null,"[#built-in-regular-expressions-engine]"),(0,l.kt)("h3",{id:"using-built-in-regular-expressions-engine"},"Using built-in regular expressions engine"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'[[ "aabbb" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"\\##"),' is: "1 or more". ',(0,l.kt)("inlineCode",{parentName:"p"},"(#c2,2)"),' is: "exactly 2". A few other constructs: ',(0,l.kt)("inlineCode",{parentName:"p"},"#"),' is "0 or more", ',(0,l.kt)("inlineCode",{parentName:"p"},"?"),' is "any character",\n',(0,l.kt)("inlineCode",{parentName:"p"},"(a|b|)"),' is "a or b or empty match". ',(0,l.kt)("inlineCode",{parentName:"p"},"#b")," enables the ",(0,l.kt)("inlineCode",{parentName:"p"},"$match")," parameters. There's also ",(0,l.kt)("inlineCode",{parentName:"p"},"#m")," but it has one parameter\n",(0,l.kt)("inlineCode",{parentName:"p"},"$MATCH")," for whole matched text, not for any parenthesis."),(0,l.kt)("p",null,"Zsh patterns are a custom regular expressions engine. They are slightly faster than the ",(0,l.kt)("inlineCode",{parentName:"p"},"zsh/regex")," module (used for\n",(0,l.kt)("inlineCode",{parentName:"p"},"=~")," operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh).\nAlso, they can be used in substitutions, for example in ",(0,l.kt)("inlineCode",{parentName:"p"},"//")," substitution."),(0,l.kt)("h3",{id:"skipping-uniq"},"Skipping uniq"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"declare -aU array; array=( a a b ); print $array \u25b6 a b\ndeclare -a array; array=( a a b ); print ${(u)array} \u25b6 a b\n")),(0,l.kt)("p",null,"Enable ",(0,l.kt)("inlineCode",{parentName:"p"},"-U")," flag for array so that it guards elements to be unique, or use ",(0,l.kt)("inlineCode",{parentName:"p"},"u"),"-flag to make unique elements of an array."),(0,l.kt)("h3",{id:"skipping-awk"},"Skipping awk"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a list; list=( "a,b,c,1,e" "p,q,r,2,t" );\nprint "${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}" \u25b6 1 2\n')),(0,l.kt)("p",null,"The pattern specifies 3 blocks of ",(0,l.kt)("inlineCode",{parentName:"p"},"[^,]##,"),' so 3 "not-comma multiple times, then comma", then the single block of\n"not-comma multiple times" in second parentheses -- and then replaces this with second parentheses. The result is the\n4th column extracted from multiple lines of text, something ',(0,l.kt)("inlineCode",{parentName:"p"},"awk")," is often used for. Another method is the use of the\n",(0,l.kt)("inlineCode",{parentName:"p"},"s"),"-flag. For a single line of text:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'text="a,b,c,1,e"; print ${${(s:,:)text}[4]} \u25b6 1\n')),(0,l.kt)("p",null,"Thanks to in-substitution code-execution capabilities it's possible to use ",(0,l.kt)("inlineCode",{parentName:"p"},"s"),"-flag to apply it to multiple lines:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a list; list=( "a,b,c,1,e" "p,q,r,2,t" );\nprint "${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}" \u25b6 1 2\n')),(0,l.kt)("p",null,"There is a problem with the ",(0,l.kt)("inlineCode",{parentName:"p"},"(s::)")," flag that can be solved if Zsh is version ",(0,l.kt)("inlineCode",{parentName:"p"},"5.4")," or higher: if there will be single\ninput column, e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},'list=( "column1" "a,b")')," instead of two or more columns (i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},'list=( "column1,column2" "a,b" )'),"),\nthen ",(0,l.kt)("inlineCode",{parentName:"p"},"(s::)")," will return ",(0,l.kt)("strong",{parentName:"p"},"string")," instead of 1-element ",(0,l.kt)("strong",{parentName:"p"},"array"),". So the index ",(0,l.kt)("inlineCode",{parentName:"p"},"[4]")," in the above snippet will index a\nstring, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer\n(",(0,l.kt)("inlineCode",{parentName:"p"},"40640: the (A) parameter flag forces array result even if..."),"), it is possible to force ",(0,l.kt)("strong",{parentName:"p"},"array"),"-kind of result even\nfor a single column, by adding ",(0,l.kt)("inlineCode",{parentName:"p"},"(A)")," flag, i.e.:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a list; list=( "a,b,c,1,e" "p,q,r,2,t" "column1" );\nprint "${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}" \u25b6 1 2\nprint "${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}" \u25b6 1 2 u\n')),(0,l.kt)("p",null,"Side-note: ",(0,l.kt)("inlineCode",{parentName:"p"},"(A)")," flag is often used together with ",(0,l.kt)("inlineCode",{parentName:"p"},"::=")," assignment-substitution and ",(0,l.kt)("inlineCode",{parentName:"p"},"(P)")," flag, to assign arrays and\nhashes by-name."),(0,l.kt)("h3",{id:"searching-arrays"},"Searching arrays"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -a array; array=( a b " c1" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"\\[[:space:]]")," contains unicode spaces. This is often used in conditional expression like ",(0,l.kt)("inlineCode",{parentName:"p"},"[[ -z ${array[(r)...]} ]]"),"."),(0,l.kt)("p",null,"Note that ",(0,l.kt)("a",{parentName:"p",href:"#skipping-grep"},"Skipping grep")," that uses ",(0,l.kt)("inlineCode",{parentName:"p"},":#")," substitution can also be used to search arrays."),(0,l.kt)("h3",{id:"code-execution-in--substitution"},"Code execution in ",(0,l.kt)("inlineCode",{parentName:"h3"},"//")," substitution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'append() { gathered+=( $array[$1] ); }\nfunctions -M append 1 1 append\ndeclare -a array; array=( "Value 1" "Other data" "Value 2" )\ndeclare -a gathered; integer idx=0\n: ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))}\nprint $gathered \u25b6 Value 1 Value 2\n')),(0,l.kt)("p",null,"Use of ",(0,l.kt)("inlineCode",{parentName:"p"},"#b")," glob flag enables math-code execution (and not only) in ",(0,l.kt)("inlineCode",{parentName:"p"},"/")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"//")," substitutions. Implementation is very\nfast."),(0,l.kt)("h3",{id:"serializing-data"},"Serializing data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'declare -A hsh deserialized; hsh=( key value )\nserialized="${(j: :)${(qkv@)hsh}}"\ndeserialized=( "${(Q@)${(z@)serialized}}" )\nprint ${(kv)deserialized} \u25b6 key value\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"j"),"-flag means join -- by spaces, in this case. Flags ",(0,l.kt)("inlineCode",{parentName:"p"},"kv")," mean: keys and values, interleaving. Important ",(0,l.kt)("inlineCode",{parentName:"p"},"q"),"-flag\nmeans: quote. So what is obtained is each key and value quoted, and put into a string separated by spaces."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"z"),"-flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting, and others) is\nrecognized. Obtained is array ",(0,l.kt)("inlineCode",{parentName:"p"},'( "key" "value")')," which is then de-quoted with ",(0,l.kt)("inlineCode",{parentName:"p"},"Q"),"-flag. This yields original data,\nassigned to hash ",(0,l.kt)("inlineCode",{parentName:"p"},"deserialized"),". Use this to e.g. implement an array of hashes."),(0,l.kt)("p",null,"Note: to be compatible with ",(0,l.kt)("inlineCode",{parentName:"p"},"setopt ksharrays"),", use ",(0,l.kt)("inlineCode",{parentName:"p"},"[@]")," instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"(@)"),", e.g.:\n",(0,l.kt)("inlineCode",{parentName:"p"},'...( "${(Q)${(z)serialized[@]}[@]}" )')),(0,l.kt)("h4",{id:"tip-serializing-with-bash"},"Tip: serializing with Bash"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'array=( key1 key2 )\nprintf -v serialized "%q " "${array[@]}"\neval "deserialized=($serialized)"\n')),(0,l.kt)("p",null,"This method works also with Zsh. The drawback is the use of ",(0,l.kt)("inlineCode",{parentName:"p"},"eval"),", however, no problem may occur unless someone\ncompromises variable's value, but as always, ",(0,l.kt)("inlineCode",{parentName:"p"},"eval")," should be avoided if possible."),(0,l.kt)("h2",{id:"real-world-examples"},"Real-world examples"),(0,l.kt)("h3",{id:"testing-for-git-subcommand"},"Testing for Git subcommand"),(0,l.kt)("p",null,"Following code checks, if there is a ",(0,l.kt)("inlineCode",{parentName:"p"},"git")," subcommand ",(0,l.kt)("inlineCode",{parentName:"p"},"$mysub"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"if git help -a | grep \"^  [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then\n")),(0,l.kt)("p",null,"Those are ",(0,l.kt)("inlineCode",{parentName:"p"},"4")," forks. The code can be replaced according to this guide:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'local -a lines_list\nlines_list=( ${(f)"$(git help -a)"} )\nlines_list=( ${(M)${(s: :)${(M)lines_list:#   [a-z]*}}:#$mysub} )\nif (( ${#lines_list} > 0 )); then\n    \u2026\nfi\n')),(0,l.kt)("p",null,"The result is just ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," fork."),(0,l.kt)("h3",{id:"counting-unquoted-only-apostrophes"},"Counting unquoted-only apostrophes"),(0,l.kt)("p",null,"A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line\nand press enters \u2013 it is the line-continuation that occurs at that moment)."),(0,l.kt)("p",null,"The required functionality is: in the given string, count the number of apostrophes, but ",(0,l.kt)("em",{parentName:"p"},"only the unquoted ones"),". This\nmeans that only apostrophes with null or an even number of preceding backslashes should be accepted into the count:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\"\ninteger count=0\n: ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))}\necho $count \u25b6 3\n")),(0,l.kt)("p",null,"The answer (i.e. the output) to the above presentation and example is: ",(0,l.kt)("inlineCode",{parentName:"p"},"3")," (there are ",(0,l.kt)("inlineCode",{parentName:"p"},"3")," unquoted apostrophes in total\nin the string kept in the variable ",(0,l.kt)("inlineCode",{parentName:"p"},"$buf"),")."),(0,l.kt)("p",null,"Below follows a variation of the above snippet that doesn't use math-code execution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\"\nbuf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##}\ninteger count=${#buf}\necho $count \u25b6 3\n")),(0,l.kt)("p",null,"This is possible thanks to ",(0,l.kt)("inlineCode",{parentName:"p"},"(S)")," flag \u2013 non-greedy matching, ",(0,l.kt)("inlineCode",{parentName:"p"},"([\\\\][\\\\])#")," trick \u2013 it matches only unquoted following\n",(0,l.kt)("inlineCode",{parentName:"p"},"(\\'\\'##)")," characters (which are the apostrophes) and a general strategy to replace ",(0,l.kt)("inlineCode",{parentName:"p"},"anything-apostrope(s)")," (unquoted\nones) with ",(0,l.kt)("inlineCode",{parentName:"p"},"the-apostrope(s)")," (and then count them with ",(0,l.kt)("inlineCode",{parentName:"p"},"${#buf}"),")."),(0,l.kt)("h2",{id:"tips-and-tricks"},"Tips and Tricks"),(0,l.kt)("h3",{id:"parsing-ini-file"},"Parsing INI file"),(0,l.kt)("p",null,"With Zshell ",(0,l.kt)("inlineCode",{parentName:"p"},"extended_glob")," parsing an ",(0,l.kt)("inlineCode",{parentName:"p"},"ini")," file is an easy task. It will not result in a nested-arrays data structure\n(Zsh doesn't support nested hashes), but the hash keys like ",(0,l.kt)("inlineCode",{parentName:"p"},"$DB_CONF[db1_<connection>_host]")," is actually intuitive."),(0,l.kt)("p",null,"The code should be placed in a file named ",(0,l.kt)("inlineCode",{parentName:"p"},"read-ini-file"),", in ",(0,l.kt)("inlineCode",{parentName:"p"},"$fpath"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"autoload read-ini-file")," should be invoked."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-shell"},'# $1 - path to the ini file to parse\n# $2 - the name of output hash\n# $3 - prefix for keys in the hash\n#\n# Writes to given hash under keys built-in following way: ${3}<section>_field.\n# Values are values from the ini file. Example invocation:\n#\n# read-ini-file ./database1-setup.ini DB_CONF db1_\n# read-ini-file ./database2-setup.ini DB_CONF db2_\n#\n\nsetopt localoptions extendedglob\n\nlocal __ini_file="$1" __out_hash="$2" __key_prefix="$3"\nlocal IFS=\'\' __line __cur_section="void" __access_string\nlocal -a match mbegin mend\n\n[[ ! -r "$__ini_file" ]] && { builtin print -r "read-ini-file: an ini file is unreadable ($__ini_file)"; return 1; }\n\nwhile read -r -t 1 __line; do\n    if [[ "$__line" = [[:blank:]]#\\;* ]]; then\n        continue\n    # Match "[Section]" line\n    elif [[ "$__line" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then\n        __cur_section="${match[1]}"\n    # Match "string = string" line\n    elif [[ "$__line" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then\n        match[2]="${match[2]%"${match[2]##*[! $\'\\t\']}"}" # severe trick - remove trailing whitespace\n        __access_string="${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]"\n        : "${(P)__access_string::=${match[2]}}"\n    fi\ndone < "$__ini_file"\n\nreturn 0\n')))}m.isMDXComponent=!0}}]);